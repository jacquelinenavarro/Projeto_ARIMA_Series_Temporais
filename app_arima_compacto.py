# -*- coding: utf-8 -*-
"""App_ARIMA_Compacto.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bDQpYlpiTyh88o4No03BqXdct_TRAMBh
"""

# ==============================================================================
# BLOCO 1: BIBLIOTECAS E FUN√á√ïES MATEM√ÅTICAS (N√öCLEO DO SISTEMA)
# ==============================================================================
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.stats import chi2, norm
import warnings
import os

# Configura√ß√µes visuais
try:
    plt.style.use('seaborn-v0_8-whitegrid')
except:
    try:
        plt.style.use('seaborn-whitegrid')
    except:
        plt.style.use('default')
plt.rcParams['figure.figsize'] = (12, 6)
warnings.filterwarnings('ignore')

# ------------------------------------------------------------------------------
# 1. FUN√á√ïES DE TRANSFORMA√á√ÉO
# ------------------------------------------------------------------------------
def aplicar_log(serie):
    """
    Aplica transforma√ß√£o Logar√≠tmica (ln) para estabilizar vari√¢ncia.
    Retorna: (s√©rie_transformada, sucesso_bool)
    """
    if np.any(serie <= 0):
        return serie, False
    return np.log(serie), True

def diferenciar_serie(serie, ordem=1):
    """
    Calcula diferen√ßas sucessivas para estacionarizar a s√©rie.
    Retorna: s√©rie diferenciada
    """
    diff = np.array(serie)
    for _ in range(ordem):
        diff = np.diff(diff)
    return diff

# ------------------------------------------------------------------------------
# 2. FUN√á√ïES DE AUTOCORRELA√á√ÉO (MANUAL)
# ------------------------------------------------------------------------------
def calcular_fac_manual(serie, lags=20):
    """
    Calcula Fun√ß√£o de Autocorrela√ß√£o (FAC) manualmente.
    Retorna: Array de correla√ß√µes at√© o lag k.
    """
    n = len(serie)
    media = np.mean(serie)
    var = np.var(serie)
    acf = np.zeros(lags + 1)
    acf[0] = 1.0

    if var == 0: return acf

    for k in range(1, lags + 1):
        cov = np.sum((serie[:-k] - media) * (serie[k:] - media)) / n
        acf[k] = cov / var
    return acf

def calcular_facp_manual(serie, lags=20):
    """
    Calcula Fun√ß√£o de Autocorrela√ß√£o Parcial (FACP) usando Durbin-Levinson.
    Retorna: Array de correla√ß√µes parciais.
    """
    acf = calcular_fac_manual(serie, lags=lags)
    pacf = np.zeros(lags + 1)
    pacf[0] = 1.0

    if lags >= 1: pacf[1] = acf[1]

    # Matriz phi para guardar coeficientes da recurs√£o
    phi = np.zeros((lags + 1, lags + 1))
    phi[1, 1] = acf[1]

    for k in range(2, lags + 1):
        # Recurs√£o de Durbin-Levinson
        num = acf[k] - np.sum(phi[k-1, 1:k] * acf[k-1:0:-1])
        den = 1 - np.sum(phi[k-1, 1:k] * acf[1:k])

        phi[k, k] = num / den if abs(den) > 1e-10 else 0
        pacf[k] = phi[k, k]

        for j in range(1, k):
            phi[k, j] = phi[k-1, j] - phi[k, k] * phi[k-1, k-j]

    return pacf

# ------------------------------------------------------------------------------
# 3. ESTIMA√á√ÉO DE PAR√ÇMETROS
# ------------------------------------------------------------------------------
def estimar_ar_yule_walker(serie, p):
    """
    Estima coeficientes AR(p) resolvendo equa√ß√µes de Yule-Walker.
    Retorna: (phi, sigma2)
    """
    if p == 0: return np.array([]), np.var(serie)

    acf = calcular_fac_manual(serie, lags=p)
    R = np.zeros((p, p)) # Matriz de Toeplitz
    for i in range(p):
        for j in range(p):
            R[i, j] = acf[abs(i - j)]

    r = acf[1:p+1]
    try:
        phi = np.linalg.solve(R, r)
        sigma2 = np.var(serie) * (1 - np.dot(r, phi))
        return phi, sigma2
    except:
        return np.zeros(p), np.var(serie)

def estimar_ma_momentos(serie, q):
    """
    Estima coeficientes MA(q) via M√©todo dos Momentos (Invers√£o da FAC).
    Retorna: (theta, sigma2)
    """
    if q == 0: return np.array([]), np.var(serie)
    acf = calcular_fac_manual(serie, lags=q)
    theta = -acf[1:q+1] # Aproxima√ß√£o simples
    sigma2 = np.var(serie) / (1 + np.sum(theta**2))
    return theta, sigma2

# ------------------------------------------------------------------------------
# 4. TESTES DE DIAGN√ìSTICO
# ------------------------------------------------------------------------------
def teste_box_pierce_ljung_box(residuos, n_params, lags=20):
    """
    Testes de Portmanteau para Ru√≠do Branco.
    Retorna: ((Q_bp, p_bp), (Q_lb, p_lb))
    """
    n = len(residuos)
    acf = calcular_fac_manual(residuos, lags=lags)
    acf_sq = acf[1:] ** 2

    # Box-Pierce
    Q_bp = n * np.sum(acf_sq)

    # Ljung-Box (Ponderado)
    pesos = np.array([(n + 2) / (n - k) for k in range(1, lags + 1)])
    Q_lb = n * np.sum(pesos * acf_sq)

    df = max(1, lags - n_params)
    p_bp = 1 - chi2.cdf(Q_bp, df)
    p_lb = 1 - chi2.cdf(Q_lb, df)

    return (Q_bp, p_bp), (Q_lb, p_lb)

def teste_periodograma_acumulado(residuos):
    """
    Teste Kolmogorov-Smirnov no Periodograma Acumulado.
    Verifica se a distribui√ß√£o espectral √© uniforme (Ru√≠do Branco).
    Retorna: (D_stat, Valor_Critico, Periodograma_Acum)
    """
    n = len(residuos)
    if n == 0: return 0, 0, np.array([])

    fft_vals = np.fft.fft(residuos - np.mean(residuos))
    periodograma = np.abs(fft_vals[:n//2])**2

    if np.sum(periodograma) == 0: return 0, 0, np.zeros(n//2)

    P_acum = np.cumsum(periodograma) / np.sum(periodograma)
    freqs = np.arange(1, len(P_acum) + 1) / len(P_acum)

    D = np.max(np.abs(P_acum - freqs))
    critico_95 = 1.36 / np.sqrt(len(P_acum))

    return D, critico_95, P_acum

def calcular_aic_bic(residuos, n_params):
    """
    Calcula Crit√©rios de Informa√ß√£o (AIC e BIC) para sele√ß√£o de modelo.
    Retorna: (AIC, BIC)
    """
    n = len(residuos)
    sse = np.sum(residuos**2)
    sigma2 = sse / n

    if sigma2 <= 0: return np.inf, np.inf

    log_lik = -0.5 * n * (np.log(2 * np.pi * sigma2) + 1)

    aic = 2 * n_params - 2 * log_lik
    bic = n_params * np.log(n) - 2 * log_lik
    return aic, bic

print("‚úÖ BLOCO 1: Fun√ß√µes Matem√°ticas Carregadas.")

# ==============================================================================
# BLOCO 2: SELE√á√ÉO DE ARQUIVO E AN√ÅLISE INICIAL
# ==============================================================================

print("--- üìÇ SELE√á√ÉO DE ARQUIVO ---")
print("1. O sistema procurar√° arquivos .csv na pasta atual.")
print("2. Voc√™ pode escolher qual arquivo usar.")
print("-" * 50)

# Procura arquivos CSV na pasta atual
arquivos_disponiveis = []
for f in os.listdir('.'):
    if f.endswith(".csv") and os.path.isfile(f):
        arquivos_disponiveis.append(f)

if len(arquivos_disponiveis) == 0:
    print("‚ùå Nenhum arquivo CSV encontrado na pasta atual.")
    print("   Por favor, coloque um arquivo .csv na mesma pasta deste script.")
else:
    # --- ESCOLHA DO ARQUIVO ---
    print(f"\nüìÇ Arquivos encontrados:")
    for i, nome in enumerate(arquivos_disponiveis):
        print(f"  [{i}] {nome}")

    idx_arq = 0
    if len(arquivos_disponiveis) > 1:
        try:
            idx_arq = int(input("Digite o N√öMERO do arquivo que deseja usar: "))
            if idx_arq < 0 or idx_arq >= len(arquivos_disponiveis):
                idx_arq = 0
        except:
            idx_arq = 0

    nome_arquivo = arquivos_disponiveis[idx_arq]
    print(f"\n‚úÖ Carregando: {nome_arquivo}...")

    # Carrega DataFrame do disco
    try:
        df = pd.read_csv(nome_arquivo)
    except Exception as e:
        print(f"Erro ao ler arquivo: {e}")
        df = pd.DataFrame()

    if not df.empty:
        # --- ESCOLHA DA COLUNA ---
        print("-" * 50)
        print(f"üìã COLUNAS DISPON√çVEIS:")
        cols = list(df.columns)
        for i, col in enumerate(cols):
            print(f"  [{i}] {col} (Tipo: {df[col].dtype})")

        escolha = input("\nDigite o N√öMERO ou NOME da coluna (S√©rie Temporal): ")

        coluna_alvo = None
        try:
            idx = int(escolha)
            if 0 <= idx < len(cols): coluna_alvo = cols[idx]
        except:
            if escolha in cols: coluna_alvo = escolha

        if coluna_alvo:
            # Pr√©-processamento
            ts = pd.to_numeric(df[coluna_alvo], errors='coerce').dropna().values

            # --- VISUALIZA√á√ÉO ---
            fig, ax = plt.subplots(2, 2, figsize=(14, 8))

            # Original
            ax[0,0].plot(ts, color='#1f77b4')
            ax[0,0].set_title(f"S√©rie Original: {coluna_alvo}")
            ax[0,1].hist(ts, bins=30, color='#1f77b4', alpha=0.7)
            ax[0,1].set_title("Histograma Original")

            # Log
            ts_log, sucesso_log = aplicar_log(ts)
            serie_trabalho = ts_log if sucesso_log else ts

            if sucesso_log:
                ax[1,0].plot(ts_log, color='#2ca02c')
                ax[1,0].set_title("S√©rie Log (ln)")
                ax[1,1].hist(ts_log, bins=30, color='#2ca02c', alpha=0.7)
                ax[1,1].set_title("Histograma (ln)")
                print(f"\n‚úÖ Coluna '{coluna_alvo}' carregada. Transforma√ß√£o Log aplicada.")
            else:
                ax[1,0].text(0.5, 0.5, "Log imposs√≠vel (valores <= 0)", ha='center')
                print(f"\n‚úÖ Coluna '{coluna_alvo}' carregada. Log n√£o aplicado (valores <= 0).")

            plt.tight_layout()
            plt.show()

            # --- FAC / FACP da Diferen√ßa ---
            print("\nüîé AN√ÅLISE DE IDENTIFICA√á√ÉO (S√©rie Diferenciada d=1):")
            ts_diff = diferenciar_serie(serie_trabalho, 1)

            fig2, ax2 = plt.subplots(1, 2, figsize=(14, 4))

            # FAC
            fac = calcular_fac_manual(ts_diff)
            ax2[0].stem(fac)
            lim = 1.96/np.sqrt(len(ts_diff))
            ax2[0].axhline(lim, c='r', ls='--'); ax2[0].axhline(-lim, c='r', ls='--')
            ax2[0].set_title("FAC (Autocorrela√ß√£o)")

            # FACP
            facp = calcular_facp_manual(ts_diff)
            ax2[1].stem(facp)
            ax2[1].axhline(lim, c='r', ls='--'); ax2[1].axhline(-lim, c='r', ls='--')
            ax2[1].set_title("FACP (Autocorrela√ß√£o Parcial)")

            plt.show()

        else:
            print("‚ùå Coluna inv√°lida.")

# ==============================================================================
# BLOCO 3: LOOP ARIMA, DIAGN√ìSTICO E SELE√á√ÉO RIGOROSA (5 CRIT√âRIOS)
# ==============================================================================

if 'serie_trabalho' not in locals():
    print("‚ùå ERRO: Execute o BLOCO 2 primeiro para carregar os dados.")
else:
    print(f"‚öôÔ∏è PROCESSANDO MODELOS PARA: '{coluna_alvo}'")
    print("   Crit√©rio de Escolha: Aprova√ß√£o nos Testes Estat√≠sticos > Menor AIC")

    resultados = []

    # --- GRID SEARCH (TESTE DE TODOS OS MODELOS) ---
    for d in [1, 2]:
        ts_diff = diferenciar_serie(serie_trabalho, ordem=d)

        for p in range(4): # p = 0,1,2,3
            for q in range(4): # q = 0,1,2,3
                if p==0 and q==0: continue

                try:
                    # 1. ESTIMA√á√ÉO
                    phi, _ = estimar_ar_yule_walker(ts_diff, p)
                    theta, _ = estimar_ma_momentos(ts_diff, q)

                    # 2. C√ÅLCULO DE RES√çDUOS
                    n = len(ts_diff)
                    residuos = np.zeros(n)
                    media = np.mean(ts_diff)

                    for t in range(max(p,q), n):
                        ar_c = np.dot(phi, (ts_diff[t-p:t]-media)[::-1]) if p>0 else 0
                        ma_c = np.dot(theta, residuos[t-q:t][::-1]) if q>0 else 0
                        pred = media + ar_c + ma_c
                        residuos[t] = ts_diff[t] - pred

                    res_val = residuos[max(p,q):]
                    if len(res_val) < 10: continue

                    # 3. OS 5 TESTES ESTAT√çSTICOS (DIAGN√ìSTICO)
                    n_par = p + q

                    # Crit√©rio 1 e 2: AIC e BIC (Super-ajustamento)
                    aic, bic = calcular_aic_bic(res_val, n_par)

                    # Crit√©rio 3 e 4: Autocorrela√ß√£o (Box-Pierce e Ljung-Box)
                    (Qbp, pbp), (Qlb, plb) = teste_box_pierce_ljung_box(res_val, n_par)

                    # Crit√©rio 5: Periodograma Acumulado (KS Test)
                    Dks, cks, _ = teste_periodograma_acumulado(res_val)

                    # --- L√ìGICA DE PONTUA√á√ÉO (DECIS√ÉO) ---
                    # Verifica quais testes de hip√≥tese o modelo passou (H0: Ru√≠do Branco)
                    passou_bp = 1 if pbp > 0.05 else 0
                    passou_lb = 1 if plb > 0.05 else 0
                    passou_ks = 1 if Dks < cks else 0

                    # Score de Diagn√≥stico (0 a 3)
                    score_diag = passou_bp + passou_lb + passou_ks

                    resultados.append({
                        'modelo': f'ARIMA({p},{d},{q})',
                        'p': p, 'd': d, 'q': q,
                        'aic': aic,        # Crit√©rio 1
                        'bic': bic,        # Crit√©rio 2
                        'p_bp': pbp,       # Crit√©rio 3
                        'p_lb': plb,       # Crit√©rio 4
                        'D_ks': Dks,       # Crit√©rio 5 (Stat)
                        'crit_ks': cks,    # Crit√©rio 5 (Limite)
                        'passou_bp': passou_bp,
                        'passou_lb': passou_lb,
                        'passou_ks': passou_ks,
                        'score': score_diag,
                        'phi': phi, 'theta': theta,
                        'residuos': res_val
                    })
                except:
                    continue

    # --- SELE√á√ÉO DO VENCEDOR ---
    if len(resultados) > 0:
        df_res = pd.DataFrame(resultados)

        # ORDENA√á√ÉO INTELIGENTE:
        # 1¬∫ Prioridade: Score de Diagn√≥stico (Maior √© melhor)
        # 2¬∫ Prioridade: AIC (Menor √© melhor)
        df_res = df_res.sort_values(by=['score', 'aic'], ascending=[False, True]).reset_index(drop=True)

        print("\n" + "="*80)
        print("üìã TOP 5 CANDIDATOS (Ordenados por: Aprova√ß√£o em Testes > Menor AIC)")
        print("="*80)

        # Mostra colunas explicativas
        display_cols = ['modelo', 'score', 'aic', 'p_lb', 'p_bp', 'passou_ks']
        print(df_res[display_cols].head(5).to_string(index=False))
        print("-" * 80)
        print("Legenda:")
        print("  score: Quantos testes estat√≠sticos de res√≠duo o modelo passou (m√°x 3).")
        print("  p_lb / p_bp: P-valor (>0.05 √© aprovado).")
        print("  passou_ks: 1 = Aprovado no Periodograma, 0 = Reprovado.")

        # --- SELE√á√ÉO DO MELHOR ---
        best = df_res.iloc[0]
        m = best.to_dict()

        # --- CORRE√á√ÉO AQUI: DEFININDO A VARI√ÅVEL GLOBAL ---
        melhor_modelo = m
        # --------------------------------------------------

        print("\n" + "="*80)
        print(f"üèÜ DIAGN√ìSTICO EXPL√çCITO DO VENCEDOR: {m['modelo']}")
        print("="*80)

        # --- EXIBI√á√ÉO EXPL√çCITA DOS 5 CRIT√âRIOS ---
        print("\nüìä AN√ÅLISE DOS 5 CRIT√âRIOS ESTAT√çSTICOS EXIGIDOS:")

        # 1. SUPER-AJUSTAMENTO (AIC)
        print(f"  1. AIC (Akaike): {m['aic']:.4f}")
        print(f"    -> Conclus√£o: {'Excelente' if m['aic'] == df_res['aic'].min() else 'Bom (Balanceado)'}. O menor AIC entre os modelos v√°lidos.")

        # 2. SUPER-AJUSTAMENTO (BIC)
        print(f"  2. BIC (Bayesiano): {m['bic']:.4f}")
        print(f"    -> Conclus√£o: Confirma a penaliza√ß√£o por complexidade.")

        # 3. TESTE DE BOX-PIERCE
        status_bp = "‚úÖ APROVADO (Res√≠duos Independentes)" if m['passou_bp'] else "‚ùå REJEITADO (Falha)"
        print(f"  3. Teste Box-Pierce: p-valor = {m['p_bp']:.4f}")
        print(f"    -> Resultado: {status_bp}")

        # 4. TESTE DE LJUNG-BOX
        status_lb = "‚úÖ APROVADO (Res√≠duos Independentes)" if m['passou_lb'] else "‚ùå REJEITADO (Autocorrela√ß√£o detectada)"
        print(f"  4. Teste Ljung-Box: p-valor = {m['p_lb']:.4f}")
        print(f"    -> Resultado: {status_lb}")

        # 5. PERIODOGRAMA ACUMULADO (KS)
        status_ks = "‚úÖ APROVADO (Ru√≠do Branco)" if m['passou_ks'] else "‚ùå REJEITADO (Padr√£o espectral detectado)"
        print(f"  5. Periodograma Acumulado (KS): D = {m['D_ks']:.4f} (Cr√≠tico: {m['crit_ks']:.4f})")
        print(f"    -> Resultado: {status_ks}")

        print("-" * 80)
        if m['score'] == 3:
            print(f"‚úÖ VEREDITO FINAL: O modelo {m['modelo']} √© estatisticamente adequado e robusto.")
        else:
            print(f"‚ö†Ô∏è VEREDITO FINAL: O modelo {m['modelo']} √© o melhor dispon√≠vel, mas n√£o passou em todos os testes.")
            print("   Sugest√£o: A s√©rie pode precisar de tratamentos adicionais (ex: GARCH) ou remo√ß√£o de outliers.")

        # --- PAR√ÇMETROS ---
        print("\nüìê PAR√ÇMETROS DO MODELO (PESOS):")
        if len(m['phi'])>0: print(f"   AR (phi): {m['phi']}")
        if len(m['theta'])>0: print(f"   MA (theta): {m['theta']}")

        # --- GR√ÅFICOS FINAIS ---
        res = m['residuos']
        fig, ax = plt.subplots(2, 2, figsize=(14, 9))
        fig.suptitle(f"Gr√°ficos de Diagn√≥stico: {m['modelo']}")

        # Res√≠duos Tempo
        ax[0,0].plot(res, c='purple', alpha=0.8)
        ax[0,0].axhline(0, c='k', ls='--')
        ax[0,0].set_title("Res√≠duos")

        # Histograma
        ax[0,1].hist(res, density=True, bins=30, color='orange', alpha=0.6)
        x = np.linspace(min(res), max(res), 100)
        ax[0,1].plot(x, norm.pdf(x, res.mean(), res.std()), 'r-')
        ax[0,1].set_title("Distribui√ß√£o dos Erros")

        # FAC Res√≠duos
        facr = calcular_fac_manual(res)
        ax[1,0].stem(facr)
        lm = 1.96/np.sqrt(len(res))
        ax[1,0].axhline(lm, c='r', ls='--'); ax[1,0].axhline(-lm, c='r', ls='--')
        ax[1,0].set_title("FAC dos Res√≠duos")

        # Periodograma
        _, _, pacum = teste_periodograma_acumulado(res)
        freqs = np.linspace(0, 1, len(pacum))
        ax[1,1].plot(freqs, pacum, label='Modelo')
        ax[1,1].plot([0,1], [0,1], 'r--', label='Ideal (Ru√≠do Branco)')
        ax[1,1].set_title("Periodograma Acumulado")
        ax[1,1].legend()

        plt.tight_layout()
        plt.show()

    else:
        print("‚ùå Nenhum modelo foi gerado. Verifique os dados de entrada.")

# ==============================================================================
# BLOCO 4: INFER√äNCIA ESTAT√çSTICA
# ==============================================================================
import re
import textwrap

# Verifica se o modelo foi gerado
if 'melhor_modelo' not in locals() or melhor_modelo is None:
    print("‚ùå ERRO: Execute o Bloco 3 para gerar o modelo antes de inferir.")
else:
    m = melhor_modelo # Conecta a vari√°vel correta

    # 1. Recupera Vari√°veis (Arquivo, Coluna, p, d, q)
    arquivo_txt = nome_arquivo if 'nome_arquivo' in locals() else "arquivo CSV"
    coluna_txt = coluna_alvo if 'coluna_alvo' in locals() else "vari√°vel de interesse"

    try:
        p, d, q = m['p'], m['d'], m['q']
    except KeyError:
        numeros = re.findall(r'\d+', m['modelo'])
        p, d, q = int(numeros[0]), int(numeros[1]), int(numeros[2])

    # 2. L√≥gica para Interpreta√ß√£o dos Termos (SEU TEXTO ORIGINAL)
    # Texto para AR
    if p == 0:
        texto_ar = "aus√™ncia de termos autorregressivos (AR)"
    elif p == 1:
        texto_ar = "um termo autorregressivo (AR), associado √† mem√≥ria de curto prazo"
    else:
        texto_ar = f"{p} termos autorregressivos (AR), indicando depend√™ncia serial de ordem superior"

    # Texto para MA
    if q == 0:
        texto_ma = "aus√™ncia de termos de m√©dia m√≥vel (MA), o que sugere que os choques aleat√≥rios n√£o possuem persist√™ncia relevante"
    elif q == 1:
        texto_ma = "um termo de m√©dia m√≥vel (MA), indicando que choques passados afetam o presente imediato"
    else:
        texto_ma = f"{q} termos de m√©dia m√≥vel (MA), indicando persist√™ncia prolongada dos choques"

    # 3. L√≥gica para Diagn√≥stico (SEU TEXTO ORIGINAL)
    if m['p_lb'] > 0.05 and m['D_ks'] < m['crit_ks']:
        texto_diag = (
            "Os testes de diagn√≥stico corroboraram o ajuste do modelo: o teste de Ljung-Box n√£o apresentou evid√™ncias "
            "de autocorrela√ß√£o nos res√≠duos (p-valor > 0,05), enquanto o teste de Kolmogorov-Smirnov aplicado ao "
            "periodograma acumulado indicou que os erros se comportam como ru√≠do branco. Dessa forma, o modelo pode "
            "ser considerado estatisticamente adequado para fins de previs√£o."
        )
    else:
        texto_diag = (
            "No entanto, os testes de diagn√≥stico indicaram ressalvas: embora o modelo tenha o melhor crit√©rio de informa√ß√£o (AIC), "
            "o teste de Ljung-Box ou o teste espectral (KS) rejeitaram a hip√≥tese de total independ√™ncia dos res√≠duos. "
            "Isso sugere que, apesar do ajuste, o modelo pode n√£o ter capturado toda a din√¢mica dos dados ou haver volatilidade condicional presente."
        )

    print("\nüìë RELAT√ìRIO DE INFER√äNCIA ESTAT√çSTICA:\n")

    # 4. Constru√ß√£o do Texto Final
    texto_final = (
        f"A an√°lise foi conduzida com base na s√©rie temporal extra√≠da do arquivo '{arquivo_txt}', utilizando os valores da coluna "
        f"'{coluna_txt}' como vari√°vel de interesse. Os resultados do processo de modelagem indicaram que o comportamento da s√©rie "
        f"√© mais adequadamente representado por um modelo ARIMA({p},{d},{q}). "
        f"Verificou-se que a s√©rie √© integrada de ordem {d} (I({d})), demandando diferencia√ß√£o para atingir estacionariedade. "
        f"A estrutura de depend√™ncia temporal √© explicada por {texto_ar} e {texto_ma}. "
        f"\n\n{texto_diag}"
    )

    # Imprime formatado
    print(textwrap.fill(texto_final, width=100))
    print("\n" + "="*80)

# ==============================================================================
# BLOCO 5: VALIDA√á√ÉO DE ACUR√ÅCIA (REAL vs MODELO)
# ==============================================================================
print("\n" + "="*80)
print("üß™ BLOCO 5: TESTE DE ACUR√ÅCIA (Real vs Ajustado)")
print("="*80)

if 'melhor_modelo' not in locals():
    print("‚ùå Execute os blocos anteriores primeiro.")
else:
    m = melhor_modelo

    # 1. Recuperar a s√©rie diferenciada e os res√≠duos
    # Precisamos alinhar os tamanhos, pois o modelo perde dados no in√≠cio (pelo d e lags)
    ts_diff = diferenciar_serie(serie_trabalho, ordem=m['d'])
    residuos = m['residuos']

    # O tamanho dos res√≠duos √© menor que a s√©rie original devido ao 'p' e 'q'
    # Vamos alinhar pelo final
    tamanho_validacao = len(residuos)
    ts_diff_recorte = ts_diff[-tamanho_validacao:]

    # 2. Reconstruir a S√©rie Diferenciada (Previsto = Real - Res√≠duo)
    # Na matem√°tica: Res√≠duo = Real - Previsto  =>  Previsto = Real - Res√≠duo
    diff_previsto = ts_diff_recorte - residuos

    # 3. Reconstruir a S√©rie Original (Integra√ß√£o)
    # Reverter a diferencia√ß√£o √© complexo sem a s√©rie original base.
    # Vamos comparar apenas no dom√≠nio transformado (Log) para simplificar a visualiza√ß√£o manual
    # ou tentar reconstruir passo a passo a partir do √≠ndice correto.

    # Vamos pegar a s√©rie de trabalho (Logada) original para alinhar
    # A s√©rie 'diff' perde m['d'] pontos. O modelo perde mais max(p,q) pontos.
    inicio_validacao = len(serie_trabalho) - tamanho_validacao
    original_log_recorte = serie_trabalho[inicio_validacao:]

    # Reconstru√ß√£o Cumulativa (Simplificada para d=1)
    if m['d'] == 1:
        # Pega o valor anterior ao in√≠cio da valida√ß√£o para servir de base
        base = serie_trabalho[inicio_validacao - 1]
        # A previs√£o acumulada √© a soma cumulativa das diferen√ßas previstas + base
        previsto_log = base + np.cumsum(diff_previsto)
    elif m['d'] == 2:
        # Para d=2 √© mais complexo reconstruir manualmente neste script compacto,
        # ent√£o vamos comparar as Diferen√ßas (Velocidade/Acelera√ß√£o) que j√° √© √∫til.
        print("‚ö†Ô∏è Para d=2, exibiremos a compara√ß√£o na escala diferenciada.")
        original_log_recorte = ts_diff_recorte
        previsto_log = diff_previsto
    else:
        # Caso d=0
        previsto_log = diff_previsto

    # 4. Reverter Log (se foi aplicado)
    # Se 'sucesso_log' for True (vari√°vel do Bloco 2), aplicamos exp
    if 'sucesso_log' in locals() and sucesso_log:
        valores_reais = np.exp(original_log_recorte)
        valores_previstos = np.exp(previsto_log)
        label_y = "Valores Originais (Destransformados)"
    else:
        valores_reais = original_log_recorte
        valores_previstos = previsto_log
        label_y = "Valores Originais"

    # 5. M√©tricas de Erro
    # RMSE (Raiz do Erro Quadr√°tico M√©dio) - Na mesma unidade dos dados
    rmse = np.sqrt(np.mean((valores_reais - valores_previstos)**2))

    # MAPE (Erro Percentual M√©dio Absoluto)
    # Evita divis√£o por zero
    mask = valores_reais != 0
    mape = np.mean(np.abs((valores_reais[mask] - valores_previstos[mask]) / valores_reais[mask])) * 100

    print(f"\nüìä RESULTADOS DA VALIDA√á√ÉO:")
    print(f"   RMSE: {rmse:.4f} (Margem de erro m√©dia na unidade da s√©rie)")
    print(f"   MAPE: {mape:.2f}% (Erro percentual m√©dio)")

    if mape < 10:
        print("   -> Classifica√ß√£o: ‚≠ê Excelente (< 10%)")
    elif mape < 20:
        print("   -> Classifica√ß√£o: ‚úÖ Bom (10-20%)")
    elif mape < 50:
        print("   -> Classifica√ß√£o: ‚ö†Ô∏è Razo√°vel (20-50%)")
    else:
        print("   -> Classifica√ß√£o: ‚ùå Ruim (> 50%) - Modelo n√£o capturou a escala corretamente.")

    # 6. Gr√°fico Final
    plt.figure(figsize=(14, 6))
    plt.plot(valores_reais, label='Real (Observado)', color='blue', alpha=0.6, linewidth=2)
    plt.plot(valores_previstos, label='Modelo (Ajustado)', color='red', linestyle='--', linewidth=2)
    plt.title(f"Teste de Acur√°cia: {m['modelo']} (MAPE: {mape:.2f}%)")
    plt.legend()
    plt.grid(True, alpha=0.3)
    plt.ylabel(label_y)
    plt.xlabel("Passos de Tempo (Amostra de Valida√ß√£o)")
    plt.show()